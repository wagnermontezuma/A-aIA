# discord_bot/bot.py - Vers√£o com sistema de conversas isoladas e monitoramento de logs.
import discord
from discord.ext import commands
import asyncio
import os
import sys
from pathlib import Path
from dotenv import load_dotenv
import hashlib
from datetime import datetime

# Adicionar o diret√≥rio pai ao path
current_dir = Path(__file__).parent
project_root = current_dir.parent
sys.path.append(str(project_root))

from agents.agent_manager import AgentManager

# Carregar vari√°veis de ambiente
load_dotenv()

class AgentEIABot(commands.Bot):
    """Bot Discord com sistema de conversas isoladas e monitoramento de logs."""

    def __init__(self):
        intents = discord.Intents.default()
        intents.message_content = True
        intents.guilds = True

        super().__init__(
            command_prefix='!',
            intents=intents,
            description="Bot de IA com agentes ADK, LangChain e Monitoramento de Logs"
        )

        self.agent_manager = None
        self.user_agent_preferences = {}
        self.synced = False

        # Inst√¢ncia global do agente de monitoramento
        self.log_monitor = None

    async def setup_hook(self):
        """Configura√ß√£o inicial com agente de monitoramento."""
        try:
            print("ü§ñ Inicializando AgentEIA Bot...")

            # Inicializar gerenciador de agentes
            self.agent_manager = AgentManager()
            print("‚úÖ Gerenciador de agentes inicializado")

            # Inicializar agente de monitoramento de logs
            try:
                from agents.log_monitor_agent import LogMonitorAgent

                # Obter webhook do Discord para alertas
                discord_webhook = os.getenv("DISCORD_WEBHOOK_URL")

                self.log_monitor = LogMonitorAgent(
                    discord_webhook_url=discord_webhook,
                    check_interval=300  # 5 minutos
                )
                print("‚úÖ Agente de monitoramento de logs inicializado")

                # Iniciar monitoramento autom√°tico
                asyncio.create_task(self.log_monitor.start_monitoring())
                print("üöÄ Monitoramento autom√°tico de logs iniciado")

            except Exception as log_error:
                print(f"‚ö†Ô∏è Erro ao inicializar monitoramento de logs: {log_error}")

            # Sincronizar comandos
            await asyncio.sleep(2)
            synced = await self.tree.sync()
            print(f"‚úÖ {len(synced)} comandos sincronizados")
            self.synced = True

        except Exception as e:
            print(f"‚ùå Erro na configura√ß√£o: {e}")

    async def on_ready(self):
        """Evento quando o bot est√° pronto."""
        print(f"üöÄ {self.user} est√° online!")
        print(f"üìä Conectado a {len(self.guilds)} servidor(es)")
        print(f"üÜî Bot ID: {self.user.id}")

        # Se n√£o estiver em nenhum servidor, mostrar link de convite
        if len(self.guilds) == 0:
            invite_url = f"https://discord.com/api/oauth2/authorize?client_id={self.user.id}&permissions=2147483648&scope=bot%20applications.commands"
            print("\n" + "="*60)
            print("‚ö†Ô∏è  BOT N√ÉO EST√Å EM NENHUM SERVIDOR!")
            print("üîó Use este link para adicionar o bot:")
            print(f"{invite_url}")
            print("="*60)
            return

        # Listar servidores conectados
        for guild in self.guilds:
            print(f"   ‚úÖ {guild.name} (ID: {guild.id})")

        # Definir atividade
        try:
            activity = discord.Activity(
                type=discord.ActivityType.watching,
                name="logs e conversando com IA"
            )
            await self.change_presence(activity=activity)
            print("‚úÖ Status definido")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao definir status: {e}")

        print("üéâ Bot totalmente operacional!")
        print("üí° Use /agenteia, /log_monitor, /log_lista no Discord!")

    def generate_session_id(self, user_id: int, guild_id: int = None, channel_id: int = None) -> str:
        """Gera ID de sess√£o √∫nico."""
        context_parts = [str(user_id)]

        if guild_id:
            context_parts.append(str(guild_id))
        if channel_id:
            context_parts.append(str(channel_id))

        today = datetime.now().strftime("%Y-%m-%d")
        context_parts.append(today)

        context_string = "_".join(context_parts)
        session_hash = hashlib.md5(context_string.encode()).hexdigest()

        return f"discord_{session_hash}"

# Inst√¢ncia global do bot
bot = AgentEIABot()

# Comandos existentes (agenteia, status) permanecem iguais...

@bot.tree.command(
    name="log_monitor",
    description="üîç Controla o sistema de monitoramento de logs"
)
@discord.app_commands.describe(
    acao="A√ß√£o: start, stop, check, status",
    data="Data espec√≠fica (YYYY-MM-DD) - opcional"
)
@discord.app_commands.choices(acao=[
    discord.app_commands.Choice(name="üöÄ Iniciar Monitoramento", value="start"),
    discord.app_commands.Choice(name="üõë Parar Monitoramento", value="stop"),
    discord.app_commands.Choice(name="üîç Verificar Hoje", value="check"),
    discord.app_commands.Choice(name="üìä Status do Sistema", value="status")
])
async def log_monitor_command(
    interaction: discord.Interaction,
    acao: discord.app_commands.Choice[str],
    data: str = None
):
    """Comando para controlar o monitoramento de logs."""
    await interaction.response.defer()

    if not bot.log_monitor:
        embed = discord.Embed(
            title="‚ùå Monitoramento Indispon√≠vel",
            description="Sistema de monitoramento de logs n√£o est√° configurado.",
            color=0xff0000
        )
        await interaction.followup.send(embed=embed)
        return

    try:
        action = acao.value

        if action == "start":
            if not bot.log_monitor.is_monitoring:
                asyncio.create_task(bot.log_monitor.start_monitoring())
                embed = discord.Embed(
                    title="üöÄ Monitoramento Iniciado",
                    description="Sistema de monitoramento de logs ativado!",
                    color=0x00ff00
                )
                embed.add_field(
                    name="üìã Configura√ß√µes",
                    value=f"üîó **URL:** {bot.log_monitor.base_url}\n‚è±Ô∏è **Intervalo:** {bot.log_monitor.check_interval}s\nüìä **Status:** üü¢ Ativo",
                    inline=False
                )
            else:
                embed = discord.Embed(
                    title="‚ö†Ô∏è J√° Ativo",
                    description="O monitoramento j√° est√° em execu√ß√£o.",
                    color=0xffff00
                )

        elif action == "stop":
            bot.log_monitor.stop_monitoring()
            embed = discord.Embed(
                title="üõë Monitoramento Parado",
                description="Sistema de monitoramento desativado.",
                color=0xff9900
            )

        elif action == "check":
            embed = discord.Embed(
                title="üîç Verificando Logs",
                description="Iniciando verifica√ß√£o manual...",
                color=0x0099ff
            )
            await interaction.followup.send(embed=embed)

            if data:
                response = await bot.log_monitor._run_async(f"verificar data {data}")
            else:
                response = await bot.log_monitor._run_async("verificar hoje")

            result_embed = discord.Embed(
                title="üìã Resultado da Verifica√ß√£o",
                description=response,
                color=0x00ff00
            )
            await interaction.followup.send(embed=result_embed)
            return

        elif action == "status":
            response = await bot.log_monitor._run_async("status")
            embed = discord.Embed(
                title="üìä Status do Sistema",
                description=response,
                color=0x0099ff
            )

        await interaction.followup.send(embed=embed)

    except Exception as e:
        error_embed = discord.Embed(
            title="‚ùå Erro",
            description=f"Erro ao executar comando: {str(e)}",
            color=0xff0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(
    name="log_lista",
    description="üìã Visualiza logs de uma data espec√≠fica"
)
@discord.app_commands.describe(
    data="Data dos logs (YYYY-MM-DD). Padr√£o: hoje",
    linhas="N√∫mero de linhas para mostrar (m√°x: 50). Padr√£o: 20"
)
async def log_lista_command(
    interaction: discord.Interaction,
    data: str = None,
    linhas: int = 20
):
    """Comando para visualizar logs diretamente no Discord."""
    await interaction.response.defer()

    if not bot.log_monitor:
        embed = discord.Embed(
            title="‚ùå Monitoramento Indispon√≠vel",
            description="Sistema de monitoramento de logs n√£o est√° configurado.",
            color=0xff0000
        )
        await interaction.followup.send(embed=embed)
        return

    try:
        # Usar data atual se n√£o especificada
        if not data:
            data = datetime.now().strftime("%Y-%m-%d")

        # Validar formato da data
        try:
            datetime.strptime(data, "%Y-%m-%d")
        except ValueError:
            embed = discord.Embed(
                title="‚ùå Data Inv√°lida",
                description="Use o formato YYYY-MM-DD (ex: 2025-06-21)",
                color=0xff0000
            )
            await interaction.followup.send(embed=embed)
            return

        # Limitar n√∫mero de linhas
        linhas = max(1, min(linhas, 50))

        print(f"üîç Buscando logs de {data}...")

        # Buscar logs
        log_content = await bot.log_monitor.fetch_logs(data)

        if not log_content:
            embed = discord.Embed(
                title="üìã Logs N√£o Encontrados",
                description=f"N√£o foi poss√≠vel acessar os logs de **{data}**.\n\nPoss√≠veis causas:\n-  Data n√£o existe\n-  Logs n√£o foram gerados\n-  Erro de acesso ao servidor",
                color=0xffff00
            )
            embed.add_field(
                name="üîó URL Tentada",
                value=f"{bot.log_monitor.base_url}/{data}",
                inline=False
            )
            await interaction.followup.send(embed=embed)
            return

        # Processar logs
        log_lines = log_content.split('\n')
        total_lines = len(log_lines)

        # Pegar as √∫ltimas N linhas
        recent_lines = log_lines[-linhas:] if total_lines > linhas else log_lines

        # Extrair erros
        errors = bot.log_monitor.extract_errors(log_content)

        # Criar embed principal
        embed = discord.Embed(
            title=f"üìã Logs de {data}",
            description=f"Exibindo **{len(recent_lines)}** linhas mais recentes de **{total_lines}** total",
            color=0x0099ff
        )

        # Adicionar estat√≠sticas
        embed.add_field(
            name="üìä Estat√≠sticas",
            value=f"üî¢ **Total de linhas:** {total_lines}\nüö® **Erros detectados:** {len(errors)}\nüìÖ **Data:** {data}",
            inline=True
        )

        embed.add_field(
            name="üîó URL",
            value=f"[Ver logs completos]({bot.log_monitor.base_url}/{data})",
            inline=True
        )

        # Adicionar amostra dos logs (limitado pelo Discord)
        log_sample = '\n'.join(recent_lines)

        # Discord tem limite de 1024 caracteres por field
        if len(log_sample) > 1000:
            log_sample = log_sample[:1000] + "..."

        embed.add_field(
            name=f"üìù √öltimas {len(recent_lines)} Linhas",
            value=f"```\n{log_sample}\n```",
            inline=False
        )

        await interaction.followup.send(embed=embed)

        # Se houver erros, enviar embed separado com detalhes
        if errors:
            error_embed = discord.Embed(
                title=f"üö® Erros Detectados em {data}",
                description=f"Encontrados **{len(errors)}** erros nos logs:",
                color=0xff0000
            )

            # Mostrar at√© 3 erros mais recentes
            for i, error in enumerate(errors[-3:], 1):
                error_embed.add_field(
                    name=f"‚ùå Erro {i}",
                    value=f"**Linha {error['line_number']}:** {error['timestamp']}\n```{error['line'][:200]}```",
                    inline=False
                )

            if len(errors) > 3:
                error_embed.add_field(
                    name="‚ÑπÔ∏è Mais Erros",
                    value=f"... e mais {len(errors) - 3} erros. Use `/log_monitor acao:check data:{data}` para an√°lise completa.",
                    inline=False
                )

            await interaction.followup.send(embed=error_embed)

    except Exception as e:
        error_embed = discord.Embed(
            title="‚ùå Erro ao Buscar Logs",
            description=f"Ocorreu um erro ao tentar buscar os logs:\n```{str(e)}```",
            color=0xff0000
        )
        await interaction.followup.send(embed=error_embed)

@bot.tree.command(
    name="log_search",
    description="üîç Busca por texto espec√≠fico nos logs"
)
@discord.app_commands.describe(
    termo="Termo para buscar nos logs",
    data="Data dos logs (YYYY-MM-DD). Padr√£o: hoje",
    limite="N√∫mero m√°ximo de resultados (m√°x: 10). Padr√£o: 5"
)
async def log_search_command(
    interaction: discord.Interaction,
    termo: str,
    data: str = None,
    limite: int = 5
):
    """Comando para buscar texto espec√≠fico nos logs."""
    await interaction.response.defer()

    if not bot.log_monitor:
        embed = discord.Embed(
            title="‚ùå Monitoramento Indispon√≠vel",
            description="Sistema de monitoramento de logs n√£o est√° configurado.",
            color=0xff0000
        )
        await interaction.followup.send(embed=embed)
        return

    try:
        # Usar data atual se n√£o especificada
        if not data:
            data = datetime.now().strftime("%Y-%m-%d")

        # Validar formato da data
        try:
            datetime.strptime(data, "%Y-%m-%d")
        except ValueError:
            embed = discord.Embed(
                title="‚ùå Data Inv√°lida",
                description="Use o formato YYYY-MM-DD (ex: 2025-06-21)",
                color=0xff0000
            )
            await interaction.followup.send(embed=embed)
            return

        # Limitar resultados
        limite = max(1, min(limite, 10))

        print(f"üîç Buscando '{termo}' nos logs de {data}...")

        # Buscar logs
        log_content = await bot.log_monitor.fetch_logs(data)

        if not log_content:
            embed = discord.Embed(
                title="üìã Logs N√£o Encontrados",
                description=f"N√£o foi poss√≠vel acessar os logs de **{data}**.",
                color=0xffff00
            )
            await interaction.followup.send(embed=embed)
            return

        # Buscar termo nos logs
        log_lines = log_content.split('\n')
        matches = []

        for i, line in enumerate(log_lines, 1):
            if termo.lower() in line.lower():
                matches.append({
                    'line_number': i,
                    'content': line.strip(),
                    'context': '\n'.join(log_lines[max(0, i-2):min(len(log_lines), i+1)])
                })

                if len(matches) >= limite:
                    break

        # Criar resposta
        if not matches:
            embed = discord.Embed(
                title="üîç Busca nos Logs",
                description=f"Nenhum resultado encontrado para **'{termo}'** em {data}",
                color=0xffff00
            )
            embed.add_field(
                name="üìä Informa√ß√µes",
                value=f"üî¢ **Linhas analisadas:** {len(log_lines)}\nüìÖ **Data:** {data}",
                inline=False
            )
        else:
            embed = discord.Embed(
                title="üîç Resultados da Busca",
                description=f"Encontrados **{len(matches)}** resultados para **'{termo}'** em {data}",
                color=0x00ff00
            )

            for i, match in enumerate(matches, 1):
                embed.add_field(
                    name=f"üìç Resultado {i} (Linha {match['line_number']})",
                    value=f"```{match['content'][:200]}```",
                    inline=False
                )

        await interaction.followup.send(embed=embed)

    except Exception as e:
        error_embed = discord.Embed(
            title="‚ùå Erro na Busca",
            description=f"Ocorreu um erro ao buscar nos logs:\n```{str(e)}```",
            color=0xff0000
        )
        await interaction.followup.send(embed=error_embed)

# Manter comandos existentes (agenteia, status, etc.)...

def run_bot():
    """Executa o bot Discord."""
    token = os.getenv("DISCORD_BOT_TOKEN")

    if not token:
        print("‚ùå DISCORD_BOT_TOKEN n√£o encontrado no .env")
        return

    try:
        print("üöÄ Iniciando bot com monitoramento de logs integrado...")
        bot.run(token)
    except discord.LoginFailure:
        print("‚ùå Token do Discord inv√°lido")
    except Exception as e:
        print(f"‚ùå Erro ao executar o bot: {e}")